<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" type="image/jpeg" href="/static/favicon-green.jpeg">
    <title>{{ room_name }} - AgentWire</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            /* Layout */
            --header-height: 60px;
            --tts-height: 40px;
            --controls-height: 190px;

            /* Theme colors - Electric Green */
            --primary: #00DD00;
            --primary-dim: #00BB00;
            --primary-dark: #009900;
            --primary-glow: rgba(0, 221, 0, 0.4);
            --primary-subtle: rgba(0, 221, 0, 0.15);

            /* Backgrounds */
            --bg-dark: #000;
            --bg-mid: #0a0a0a;
            --bg-light: #111;
            --bg-elevated: #1a1a1a;

            /* Text */
            --text-primary: #E8EEF2;
            --text-secondary: #8899A6;
            --text-muted: #5C6B7A;

            /* Borders */
            --border: #2A3A4D;
            --border-light: #3D4F63;

            /* States - semantic colors */
            --success: #4ADE80;
            --warning: #FBBF24;
            --error: #F87171;
            --info: var(--primary);

            /* Orb states */
            --orb-idle: var(--primary);
            --orb-idle-dark: var(--primary-dark);
            --orb-listening: #FBBF24;
            --orb-listening-dark: #D97706;
            --orb-processing: #A855F7;
            --orb-processing-dark: #7C3AED;
            --orb-generating: #3B82F6;
            --orb-generating-dark: #1D4ED8;
            --orb-speaking: #4ADE80;
            --orb-speaking-dark: #22C55E;
            --orb-awaiting: #FBBF24;
            --orb-awaiting-dark: #D97706;
        }
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .header {
            height: var(--header-height);
            padding: 0 1rem;
            background: #000;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .header h1 { font-size: 1.25rem; color: var(--text-secondary); }
        .header a { color: var(--text-muted); text-decoration: none; font-size: 0.9rem; }
        .header-brand { color: var(--primary); font-weight: 600; font-size: 1.1rem; margin-right: 0.75rem; text-decoration: none; display: flex; align-items: center; gap: 0.4rem; }
        .header-logo { width: 32px; height: 32px; border-radius: 4px; }
        .header-left { display: flex; align-items: center; }
        .header-right { display: flex; align-items: center; gap: 0.75rem; }
        .settings-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        .settings-btn:hover { color: var(--primary); }
        .settings-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-light);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 0.75rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .settings-dropdown.open { display: flex; }
        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .settings-group label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .settings-group select, .settings-group button {
            padding: 0.6rem 0.75rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            width: 100%;
            text-align: left;
        }
        .settings-group select:hover, .settings-group button:hover {
            border-color: var(--primary);
        }
        .header-right { position: relative; }
        .status { font-size: 1rem; color: var(--text-muted); }
        .status.connected { color: var(--primary); }

        /* Terminal mode */
        .output {
            flex: 1;
            padding: 1rem;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            font-family: ui-monospace, monospace;
            font-size: 0.8rem;
            background: var(--bg-dark);
            color: var(--text-secondary);
            min-height: 0;
        }
        .output-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Ambient mode container */
        .ambient {
            flex: 1;
            display: none;
            flex-direction: column;
            background: var(--bg-dark);
            min-height: 0;
            position: relative;
        }
        .ambient.active { display: flex; }
        .output.hidden { display: none; }

        /* AI Speech bubble - top (floating overlay) */
        .ai-bubble-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 1.25rem;
            z-index: 10;
            pointer-events: none;
        }
        .ai-bubble {
            pointer-events: auto;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 16px;
            border-top-left-radius: 4px;
            padding: 1rem 1.25rem;
            font-size: 1.1rem;
            line-height: 1.5;
            color: var(--text-primary);
            max-width: 92%;
            position: relative;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        .ai-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .ai-bubble.speaking {
            border-color: var(--orb-speaking);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
        }
        .ai-bubble::before {
            content: 'ü§ñ';
            position: absolute;
            top: -0.5rem;
            left: -0.5rem;
            font-size: 1.3rem;
        }

        /* Orb area - center */
        .orb-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }

        /* State label */
        .state-label {
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        .state-label.idle { color: var(--orb-idle); }
        .state-label.listening { color: var(--orb-listening); }
        .state-label.processing { color: var(--orb-processing); }
        .state-label.generating { color: var(--orb-generating); }
        .state-label.speaking { color: var(--orb-speaking); }

        /* Orb container */
        .orb-container {
            position: relative;
            width: 200px;
            height: 200px;
        }
        .orb {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .orb-ring {
            position: absolute;
            inset: -10%;
            border-radius: 50%;
            border: 2px solid var(--primary-subtle);
            transition: all 0.3s ease;
        }

        /* Orb states */
        .orb.idle {
            background: radial-gradient(circle at 30% 30%, var(--orb-idle), var(--orb-idle-dark));
            animation: breathe 4s ease-in-out infinite;
            box-shadow: 0 0 60px var(--primary-glow);
        }
        .orb-ring.idle {
            animation: ring-breathe 4s ease-in-out infinite;
            border-color: var(--primary-subtle);
        }
        .orb.listening {
            background: radial-gradient(circle at 30% 30%, var(--orb-listening), var(--orb-listening-dark));
            animation: listen 0.8s ease-in-out infinite;
            box-shadow: 0 0 80px rgba(245, 158, 11, 0.4);
        }
        .orb-ring.listening {
            animation: ring-listen 0.8s ease-in-out infinite;
            border-color: rgba(245, 158, 11, 0.4);
        }
        .orb.processing {
            background: conic-gradient(from 0deg, var(--orb-processing), var(--orb-processing-dark), var(--orb-processing));
            animation: spin 1.5s linear infinite, pulse-processing 0.8s ease-in-out infinite;
            box-shadow: 0 0 60px rgba(168, 85, 247, 0.4);
        }
        .orb-ring.processing {
            animation: ring-spin 3s linear infinite reverse;
            border-color: rgba(168, 85, 247, 0.4);
            border-width: 3px;
            border-style: dashed;
        }
        .orb.generating {
            background: radial-gradient(circle at 30% 30%, var(--orb-generating), var(--orb-generating-dark));
            animation: generate 0.6s ease-in-out infinite;
            box-shadow: 0 0 80px rgba(56, 189, 248, 0.5);
        }
        .orb-ring.generating {
            animation: ring-generate 0.6s ease-in-out infinite;
            border-color: rgba(56, 189, 248, 0.5);
            border-width: 3px;
        }
        .orb.speaking {
            background: radial-gradient(circle at 30% 30%, var(--orb-speaking), var(--orb-speaking-dark));
            animation: speak 0.25s ease-in-out infinite;
            box-shadow: 0 0 100px rgba(45, 212, 191, 0.5);
        }
        .orb-ring.speaking {
            animation: ring-speak 0.4s ease-in-out infinite;
            border-color: rgba(45, 212, 191, 0.5);
            border-width: 3px;
        }
        .orb.locked {
            background: radial-gradient(circle at 30% 30%, var(--text-muted), var(--bg-elevated));
            animation: breathe 4s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(92, 107, 122, 0.3);
            opacity: 0.6;
        }
        .orb-ring.locked {
            animation: ring-breathe 4s ease-in-out infinite;
            border-color: rgba(92, 107, 122, 0.3);
        }
        .state-label.locked { color: var(--text-secondary); }
        /* Awaiting permission state - orange/amber */
        .orb.awaiting_permission {
            background: radial-gradient(circle at 30% 30%, var(--orb-awaiting), var(--orb-awaiting-dark));
            animation: awaiting-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 80px rgba(251, 191, 36, 0.5);
        }
        .orb-ring.awaiting_permission {
            animation: ring-awaiting 1.5s ease-in-out infinite;
            border-color: rgba(251, 191, 36, 0.5);
            border-width: 3px;
        }
        .state-label.awaiting_permission { color: var(--orb-awaiting); }
        @keyframes awaiting-pulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.05); opacity: 1; }
        }
        @keyframes ring-awaiting {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.03); opacity: 1; }
        }
        @keyframes ring-breathe {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.05); opacity: 0.5; }
        }
        @keyframes listen {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        @keyframes ring-listen {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.15); opacity: 0.7; }
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes pulse-processing {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        @keyframes ring-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes work {
            0%, 100% { transform: scale(1); opacity: 0.85; }
            50% { transform: scale(1.04); opacity: 1; }
        }
        @keyframes ring-work {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.08); opacity: 0.6; }
        }
        @keyframes generate {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.06); opacity: 1; }
        }
        @keyframes ring-generate {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.12); opacity: 0.8; }
        }
        @keyframes speak {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.12); }
        }
        @keyframes ring-speak {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.9; }
        }

        /* User bubble - bottom (floating overlay, above controls) */
        .user-bubble-container {
            position: absolute;
            bottom: 140px; /* Above floating controls */
            left: 0;
            right: 0;
            padding: 0 1.5rem;
            z-index: 10;
            pointer-events: none;
            display: flex;
            justify-content: flex-end;
        }
        .user-bubble {
            pointer-events: auto;
            background: var(--primary-subtle);
            border: 1px solid rgba(0, 221, 0, 0.3);
            border-radius: 16px;
            border-bottom-right-radius: 4px;
            padding: 1rem 1.25rem;
            font-size: 1.1rem;
            line-height: 1.5;
            color: var(--text-primary);
            max-width: 92%;
            margin-left: auto;
            position: relative;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }
        .user-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .user-bubble.listening {
            border-color: var(--orb-listening);
            background: rgba(245, 158, 11, 0.15);
        }
        .user-bubble::after {
            content: 'üë§';
            position: absolute;
            bottom: -0.5rem;
            right: -0.5rem;
            font-size: 1.2rem;
        }

        /* Floating controls container - works in both modes */
        .floating-controls {
            position: fixed;
            bottom: 2rem;
            left: 1.5rem;
            right: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 50;
        }
        .floating-controls > * {
            pointer-events: auto;
        }

        /* Text input - left side */
        .text-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            margin-right: 1rem;
        }
        .text-toggle-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            color: var(--text-secondary);
            font-size: 1.75rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .text-toggle-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        .text-toggle-btn.active {
            background: var(--primary-subtle);
            border-color: var(--primary);
            color: var(--primary);
        }
        .text-input-expanded {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 28px;
            padding: 0.25rem 0.5rem 0.25rem 1rem;
            flex: 0;
            overflow: hidden;
            opacity: 0;
            transition: all 0.3s ease;
        }
        .text-input-expanded.open {
            flex: 1;
            opacity: 1;
        }
        .text-input-expanded input {
            flex: 1;
            min-width: 0;
            padding: 0.5rem 0;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.25rem;
        }
        .text-input-expanded input:focus {
            outline: none;
        }
        .text-input-expanded input::placeholder {
            color: var(--text-muted);
        }
        .send-btn {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: var(--primary);
            border: none;
            color: #000;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: var(--primary-dim);
            transform: scale(1.05);
        }
        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Mic button - right side */
        .mic-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        .mic-btn.idle {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: #000;
            box-shadow: 0 4px 20px var(--primary-glow);
        }
        .mic-btn.listening {
            background: linear-gradient(135deg, var(--orb-listening), var(--orb-listening-dark));
            color: #000;
            animation: mic-pulse 0.8s ease-in-out infinite;
            box-shadow: 0 4px 30px rgba(245, 158, 11, 0.5);
        }
        .mic-btn.processing {
            background: linear-gradient(135deg, var(--orb-processing), var(--orb-processing-dark));
            color: #fff;
            cursor: not-allowed;
            opacity: 0.8;
        }
        .mic-btn.generating {
            background: linear-gradient(135deg, var(--orb-generating), var(--orb-generating-dark));
            color: #fff;
            cursor: not-allowed;
            animation: mic-pulse 0.6s ease-in-out infinite;
        }
        .mic-btn.speaking {
            background: linear-gradient(135deg, var(--orb-speaking), var(--orb-speaking-dark));
            color: #000;
        }
        .mic-btn.locked {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-light));
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.6;
        }
        .mic-btn.awaiting_permission {
            background: linear-gradient(135deg, var(--orb-awaiting), var(--orb-awaiting-dark));
            color: #000;
            animation: mic-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 4px 30px rgba(251, 191, 36, 0.5);
        }

        /* Mic area with actions */
        .mic-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
            position: relative;
        }
        .actions-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            display: none;  /* Hidden in ambient mode */
            z-index: 100;  /* Above actions menu */
            position: relative;
        }
        .terminal-mode .actions-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .actions-btn:hover {
            background: var(--bg-light);
            color: var(--text-primary);
            border-color: var(--primary);
        }
        .actions-btn.active {
            background: var(--primary);
            color: #1a1a1a;
            border-color: var(--primary);
        }
        .actions-menu {
            position: absolute;
            bottom: 100%;  /* Stack above mic-area content */
            right: 0;
            margin-bottom: 0.5rem;
            display: none;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
            z-index: 100;
            pointer-events: auto;
        }
        .actions-menu.open {
            display: flex;
        }
        .action-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 1px solid #444;
            background: #1a1a1a;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .action-item:hover {
            background: var(--primary);
            color: #1a1a1a;
            border-color: var(--primary);
        }
        .action-item:hover .action-label {
            opacity: 1;
            transform: translateX(0);
        }
        .action-label {
            position: absolute;
            right: 70px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            opacity: 0;
            transform: translateX(10px);
            transition: all 0.15s;
            pointer-events: none;
            z-index: 200;
        }

        @keyframes mic-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }


        /* Ambient mode attach */
        .text-input-expanded .attach-btn-ambient {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1rem;
            cursor: pointer;
            padding: 0 0.5rem;
        }
        .text-input-expanded .attach-btn-ambient:hover { color: var(--primary); }
        .text-input-expanded .attach-btn-ambient.has-image { color: var(--primary); }
        .ambient-image-preview {
            display: none;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 0.5rem;
        }
        .ambient-image-preview.visible { display: block; }

        /* Start in ambient mode by default via CSS */
        .output.ambient-default { display: none; }
        .ambient.ambient-default { display: flex; }

        /* Question popup modal */
        .question-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .question-modal.visible { display: flex; }
        .question-card {
            background: var(--bg-elevated);
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 1.5rem;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 0 40px var(--primary-glow);
        }
        .question-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .question-header .badge {
            background: var(--primary-subtle);
            color: var(--primary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .question-text {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 1.25rem;
            line-height: 1.4;
        }
        .question-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .question-option {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
        }
        .question-option:hover {
            background: var(--primary-subtle);
            border-color: var(--primary);
        }
        .question-option .num {
            background: var(--primary);
            color: var(--bg-primary);
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        .question-option .label {
            color: var(--text-primary);
            font-size: 0.95rem;
            line-height: 1.4;
        }
        .question-option .desc {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-top: 0.25rem;
        }
        .question-custom {
            margin-top: 0.75rem;
            display: none;
        }
        .question-custom.visible { display: block; }
        .question-custom input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        .question-custom input:focus {
            outline: none;
            border-color: var(--primary);
        }
        /* Type something option */
        .question-option.type-option {
            cursor: default;
        }
        .question-option.type-option:hover {
            background: var(--bg-secondary);
            border-color: var(--border);
        }
        .type-input-wrapper {
            flex: 1;
            display: flex;
            gap: 0.5rem;
        }
        .type-input {
            flex: 1;
            padding: 0.5rem 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
        .type-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .type-submit {
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: #1a1a1a;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.15s;
        }
        .type-submit:hover {
            opacity: 0.9;
        }

        /* Permission modal */
        .permission-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .permission-modal.visible { display: flex; }
        .permission-card {
            background: var(--bg-elevated);
            border: 2px solid var(--orb-awaiting);
            border-radius: 16px;
            padding: 1.5rem;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 0 40px rgba(251, 191, 36, 0.4);
        }
        .permission-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .permission-header .icon {
            font-size: 1.5rem;
        }
        .permission-header .badge {
            background: rgba(251, 191, 36, 0.2);
            color: var(--orb-awaiting);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .permission-title {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        .permission-target {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--primary);
            background: var(--bg-secondary);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            word-break: break-all;
        }
        .permission-diff {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 1rem;
            max-height: 300px;
            overflow: auto;
        }
        .permission-diff pre {
            margin: 0;
            padding: 0.75rem;
            font-family: monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .permission-diff .line-removed {
            color: #F87171;
            background: rgba(248, 113, 113, 0.1);
        }
        .permission-diff .line-added {
            color: #4ADE80;
            background: rgba(74, 222, 128, 0.1);
        }
        .permission-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .permission-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .permission-btn.allow {
            background: var(--primary);
            color: #1a1a1a;
        }
        .permission-btn.allow:hover {
            opacity: 0.9;
        }
        .permission-btn.deny {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        .permission-btn.deny:hover {
            background: rgba(248, 113, 113, 0.2);
            border-color: #F87171;
            color: #F87171;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <a href="/" class="header-brand"><img src="/static/logo-green.jpeg" alt="" class="header-logo">AgentWire</a>
            <div>
                <h1>{{ room_name }}{% if config.machine %}<span style="color:var(--text-muted);font-weight:normal">@{{ config.machine }}</span>{% endif %}</h1>
                <div class="status" id="status">connecting...</div>
            </div>
        </div>
        <div class="header-right">
            <button class="settings-btn" id="settingsBtn" onclick="toggleSettings()" title="Settings">‚öô</button>
            <div class="settings-dropdown" id="settingsDropdown">
                <div class="settings-group">
                    <label>View</label>
                    <button id="modeToggle" onclick="toggleMode()">Switch to Terminal</button>
                </div>
                <div class="settings-group">
                    <label>Microphone</label>
                    <select id="micSelect" onchange="updateMic()">
                        <option value="">Default Mic</option>
                    </select>
                </div>
                <div class="settings-group">
                    <label>Speaker</label>
                    <select id="speakerSelect" onchange="updateSpeaker()">
                        <option value="">Default Speaker</option>
                    </select>
                </div>
                <div class="settings-group">
                    <label>TTS Voice</label>
                    <select id="voiceSelect" onchange="updateVoice()">
                        {% for voice in voices %}
                        <option value="{{ voice }}"{% if voice == current_voice %} selected{% endif %}>{{ voice }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="settings-group">
                    <label>Exaggeration</label>
                    <input type="range" id="exaggeration" min="0" max="1" step="0.1" value="{{ config.exaggeration }}" onchange="updateTTS()" style="width:100%">
                </div>
                <div class="settings-group">
                    <label>CFG Weight</label>
                    <input type="range" id="cfgWeight" min="0" max="1" step="0.1" value="{{ config.cfg_weight }}" onchange="updateTTS()" style="width:100%">
                </div>
            </div>
        </div>
    </div>

    <!-- Terminal Mode -->
    <div class="output ambient-default" id="output"><div class="output-content" id="outputContent"></div></div>

    <!-- Ambient Mode -->
    <div class="ambient ambient-default" id="ambient">
        <!-- AI message at top -->
        <div class="ai-bubble-container">
            <div class="ai-bubble" id="aiBubble"></div>
        </div>

        <!-- Orb in center -->
        <div class="orb-area">
            <div class="state-label idle" id="stateLabel">Ready</div>
            <div class="orb-container">
                <div class="orb-ring idle" id="orbRing"></div>
                <div class="orb idle" id="orb"></div>
            </div>
        </div>

        <!-- User message bubble -->
        <div class="user-bubble-container">
            <div class="user-bubble" id="userBubble"></div>
        </div>

    </div>

    <!-- Floating controls (both modes) -->
    <div class="floating-controls" id="floatingControls">
        <!-- Text input on left -->
        <div class="text-input-wrapper">
            <button class="text-toggle-btn" id="textToggleBtn" onclick="toggleTextInput()">‚å®</button>
            <div class="text-input-expanded" id="textInputExpanded">
                <button class="attach-btn-ambient" id="attachBtnAmbient" onclick="triggerFileInput()" title="Attach image">üìé</button>
                <img class="ambient-image-preview" id="ambientImagePreview" src="" alt="">
                <input type="text" id="textInputAmbient" placeholder="Type a message..." autocomplete="off">
                <button class="send-btn" id="sendBtnAmbient" onclick="sendTextInputAmbient()">‚Üë</button>
            </div>
        </div>

        <!-- Mic area with actions menu -->
        <div class="mic-area">
            <!-- Actions menu (pops up above) -->
            <div class="actions-menu" id="actionsMenu">
                {% if is_system_session %}
                <button class="action-item" onclick="actionRestartService()">
                    <span class="action-icon">üîÑ</span>
                    <span class="action-label">Restart Service</span>
                </button>
                {% endif %}
                {% if is_project_session %}
                <button class="action-item" onclick="actionNewRoom()">
                    <span class="action-icon">‚ûï</span>
                    <span class="action-label">New Room</span>
                </button>
                <button class="action-item" onclick="actionForkSession()">
                    <span class="action-icon">üç¥</span>
                    <span class="action-label">Fork Session</span>
                </button>
                <button class="action-item" onclick="actionRecreateSession()">
                    <span class="action-icon">üîÑ</span>
                    <span class="action-label">Recreate Session</span>
                </button>
                {% endif %}
            </div>
            <!-- Actions toggle button -->
            <button class="actions-btn" id="actionsBtn" onclick="toggleActionsMenu()">‚ãØ</button>
            <!-- Mic button -->
            <button class="mic-btn idle" id="micBtn">üé§</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="handleFileSelect(event)">

    <!-- Question popup modal -->
    <div class="question-modal" id="questionModal">
        <div class="question-card">
            <div class="question-header">
                <span class="badge" id="questionBadge">Question</span>
            </div>
            <div class="question-text" id="questionText"></div>
            <div class="question-options" id="questionOptions"></div>
            <div class="question-custom" id="questionCustom">
                <input type="text" id="questionCustomInput" placeholder="Type your answer..." autocomplete="off">
            </div>
        </div>
    </div>

    <!-- Permission request modal -->
    <div class="permission-modal" id="permissionModal">
        <div class="permission-card">
            <div class="permission-header">
                <span class="icon">&#x1F512;</span>
                <span class="badge">Permission Request</span>
            </div>
            <div class="permission-title" id="permissionTitle">Claude wants to...</div>
            <div class="permission-target" id="permissionTarget"></div>
            <div class="permission-diff" id="permissionDiff" style="display: none;">
                <pre id="permissionDiffContent"></pre>
            </div>
            <div class="permission-actions">
                <button class="permission-btn deny" onclick="respondToPermission('deny')">Deny</button>
                <button class="permission-btn allow" onclick="respondToPermission('allow')">Allow</button>
            </div>
        </div>
    </div>

    <script>
        const ROOM = '{{ room_name }}';
        const IS_SYSTEM_SESSION = {{ is_system_session_js }};
        const elements = {
            output: document.getElementById('output'),
            outputContent: document.getElementById('outputContent'),
            ambient: document.getElementById('ambient'),
            orb: document.getElementById('orb'),
            orbRing: document.getElementById('orbRing'),
            stateLabel: document.getElementById('stateLabel'),
            status: document.getElementById('status'),
            micBtn: document.getElementById('micBtn'),
            modeToggle: document.getElementById('modeToggle'),
            micSelect: document.getElementById('micSelect'),
            speakerSelect: document.getElementById('speakerSelect'),
            settingsDropdown: document.getElementById('settingsDropdown'),
            aiBubble: document.getElementById('aiBubble'),
            userBubble: document.getElementById('userBubble'),
            aiBubbleContainer: document.querySelector('.ai-bubble-container'),
            questionModal: document.getElementById('questionModal'),
            questionBadge: document.getElementById('questionBadge'),
            questionText: document.getElementById('questionText'),
            questionOptions: document.getElementById('questionOptions'),
            questionCustom: document.getElementById('questionCustom'),
            questionCustomInput: document.getElementById('questionCustomInput'),
            permissionModal: document.getElementById('permissionModal'),
            permissionTitle: document.getElementById('permissionTitle'),
            permissionTarget: document.getElementById('permissionTarget'),
            permissionDiff: document.getElementById('permissionDiff'),
            permissionDiffContent: document.getElementById('permissionDiffContent'),
            userBubbleContainer: document.querySelector('.user-bubble-container'),
            textToggleBtn: document.getElementById('textToggleBtn'),
            textInputExpanded: document.getElementById('textInputExpanded'),
            textInputAmbient: document.getElementById('textInputAmbient'),
            attachBtnAmbient: document.getElementById('attachBtnAmbient'),
            ambientImagePreview: document.getElementById('ambientImagePreview'),
            fileInput: document.getElementById('fileInput'),
            actionsBtn: document.getElementById('actionsBtn'),
            actionsMenu: document.getElementById('actionsMenu')
        };

        let textInputOpen = false;
        let pendingImage = null;  // { file: File, preview: dataURL, filename: string }

        function toggleTextInput() {
            textInputOpen = !textInputOpen;
            elements.textToggleBtn.classList.toggle('active', textInputOpen);
            elements.textInputExpanded.classList.toggle('open', textInputOpen);
            if (textInputOpen) {
                setTimeout(() => elements.textInputAmbient.focus(), 100);
            }
        }

        function toggleSettings() {
            elements.settingsDropdown.classList.toggle('open');
        }

        // Actions menu
        function toggleActionsMenu() {
            const isOpen = elements.actionsMenu.classList.toggle('open');
            elements.actionsBtn.classList.toggle('active', isOpen);
        }

        function closeActionsMenu() {
            elements.actionsMenu.classList.remove('open');
            elements.actionsBtn.classList.remove('active');
        }

        async function actionNewRoom() {
            closeActionsMenu();

            try {
                const resp = await fetch(`/api/room/${ROOM}/spawn-sibling`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (resp.ok && data.session) {
                    // Open new room in new tab
                    window.open(`/room/${data.session}`, '_blank');
                } else {
                    alert('Failed to create new room: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Failed to create new room:', e);
                alert('Failed to create new room');
            }
        }

        async function actionForkSession() {
            closeActionsMenu();

            try {
                const resp = await fetch(`/api/room/${ROOM}/fork`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (resp.ok && data.session) {
                    // Open forked room in new tab
                    window.open(`/room/${data.session}`, '_blank');
                } else {
                    alert('Failed to fork session: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Failed to fork session:', e);
                alert('Failed to fork session');
            }
        }

        async function actionRecreateSession() {
            closeActionsMenu();

            if (!confirm('Recreate this session?\n\nThis will:\n‚Ä¢ Close Claude Code and destroy the tmux session\n‚Ä¢ Remove the git worktree directory\n‚Ä¢ Pull latest changes\n‚Ä¢ Create a fresh worktree and session')) {
                return;
            }

            try {
                const resp = await fetch(`/api/room/${ROOM}/recreate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (resp.ok) {
                    // Redirect to new session (may have different name)
                    if (data.session && data.session !== ROOM) {
                        window.location.href = `/room/${data.session}`;
                    } else {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to recreate session: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Failed to recreate session:', e);
                alert('Failed to recreate session');
            }
        }

        async function actionRestartService() {
            closeActionsMenu();

            const serviceName = ROOM.split('@')[0];
            if (!confirm(`Restart the ${serviceName} service?`)) {
                return;
            }

            try {
                const resp = await fetch(`/api/room/${ROOM}/restart-service`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await resp.json();
                if (resp.ok) {
                    alert(data.message || 'Service restarted');
                    // For portal, page will become unavailable briefly
                    if (serviceName === 'agentwire-portal') {
                        setTimeout(() => window.location.reload(), 3000);
                    } else {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to restart service: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Failed to restart service:', e);
                alert('Failed to restart service');
            }
        }

        // Close actions menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!elements.actionsBtn.contains(e.target) && !elements.actionsMenu.contains(e.target)) {
                closeActionsMenu();
            }
        });

        // Image attachment functions
        function triggerFileInput() {
            elements.fileInput.click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                attachImage(file);
            }
            event.target.value = '';  // Reset so same file can be selected again
        }

        function attachImage(file) {
            if (!file.type.startsWith('image/')) {
                console.warn('Not an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                pendingImage = {
                    file: file,
                    preview: e.target.result,
                    filename: file.name
                };
                showImagePreview();
            };
            reader.readAsDataURL(file);
        }

        function showImagePreview() {
            if (!pendingImage) return;
            elements.ambientImagePreview.src = pendingImage.preview;
            elements.ambientImagePreview.classList.add('visible');
            elements.attachBtnAmbient.classList.add('has-image');
        }

        function removeImage() {
            pendingImage = null;
            elements.ambientImagePreview.classList.remove('visible');
            elements.attachBtnAmbient.classList.remove('has-image');
        }

        async function uploadImage() {
            if (!pendingImage) {
                console.log('uploadImage: no pending image');
                return null;
            }

            console.log('uploadImage: uploading', pendingImage.filename);
            const formData = new FormData();
            formData.append('image', pendingImage.file);

            try {
                const resp = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                const data = await resp.json();
                console.log('uploadImage response:', data);
                if (data.error) {
                    console.error('Upload failed:', data.error);
                    alert('Image upload failed: ' + data.error);
                    return null;
                }
                console.log('uploadImage success:', data.path);
                return data.path;
            } catch (err) {
                console.error('Upload error:', err);
                alert('Image upload error: ' + err.message);
                return null;
            }
        }

        // Paste handler for images
        document.addEventListener('paste', async (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        attachImage(file);
                    }
                    break;
                }
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.header-right')) {
                elements.settingsDropdown.classList.remove('open');
            }
        });

        // Audio device selection
        let selectedMicId = localStorage.getItem('agentwire-mic-id') || '';
        let selectedSpeakerId = localStorage.getItem('agentwire-speaker-id') || '';

        async function populateAudioDevices() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => stream.getTracks().forEach(t => t.stop()));

                const devices = await navigator.mediaDevices.enumerateDevices();

                const mics = devices.filter(d => d.kind === 'audioinput');
                elements.micSelect.innerHTML = '<option value="">Default Mic</option>';
                mics.forEach(mic => {
                    const opt = document.createElement('option');
                    opt.value = mic.deviceId;
                    opt.textContent = mic.label || `Microphone ${mic.deviceId.slice(0, 8)}`;
                    if (mic.deviceId === selectedMicId) opt.selected = true;
                    elements.micSelect.appendChild(opt);
                });

                const speakers = devices.filter(d => d.kind === 'audiooutput');
                elements.speakerSelect.innerHTML = '<option value="">Default Speaker</option>';
                speakers.forEach(speaker => {
                    const opt = document.createElement('option');
                    opt.value = speaker.deviceId;
                    opt.textContent = speaker.label || `Speaker ${speaker.deviceId.slice(0, 8)}`;
                    if (speaker.deviceId === selectedSpeakerId) opt.selected = true;
                    elements.speakerSelect.appendChild(opt);
                });

                if (!('setSinkId' in HTMLAudioElement.prototype)) {
                    elements.speakerSelect.style.display = 'none';
                }
            } catch (e) {
                console.log('Could not enumerate audio devices:', e);
            }
        }

        function updateMic() {
            selectedMicId = elements.micSelect.value;
            localStorage.setItem('agentwire-mic-id', selectedMicId);
        }

        function updateSpeaker() {
            selectedSpeakerId = elements.speakerSelect.value;
            localStorage.setItem('agentwire-speaker-id', selectedSpeakerId);
        }

        // ANSI to HTML converter
        function ansiToHtml(text) {
            const colors = {
                '30': '#000', '31': '#e55', '32': '#5e5', '33': '#ee5',
                '34': '#55e', '35': '#e5e', '36': '#5ee', '37': '#eee',
                '90': '#888', '91': '#f88', '92': '#8f8', '93': '#ff8',
                '94': '#88f', '95': '#f8f', '96': '#8ff', '97': '#fff',
                '39': '#aaa'
            };
            const bgColors = {
                '40': '#000', '41': '#a00', '42': '#0a0', '43': '#a50',
                '44': '#00a', '45': '#a0a', '46': '#0aa', '47': '#aaa',
                '49': 'transparent'
            };

            let html = '';
            let currentStyle = {};
            const regex = /\x1b\[([0-9;]*)m/g;
            let lastIndex = 0;
            let match;

            while ((match = regex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    const chunk = text.slice(lastIndex, match.index);
                    html += escapeHtml(chunk);
                }

                const codes = match[1].split(';').filter(c => c !== '');
                for (const code of codes) {
                    if (code === '0' || code === '') {
                        currentStyle = {};
                    } else if (code === '1') {
                        currentStyle.bold = true;
                    } else if (code === '2') {
                        currentStyle.dim = true;
                    } else if (code === '3') {
                        currentStyle.italic = true;
                    } else if (code === '4') {
                        currentStyle.underline = true;
                    } else if (colors[code]) {
                        currentStyle.color = colors[code];
                    } else if (bgColors[code]) {
                        currentStyle.bg = bgColors[code];
                    }
                }

                html += '</span>';
                const styles = [];
                if (currentStyle.color) styles.push(`color:${currentStyle.color}`);
                if (currentStyle.bg && currentStyle.bg !== 'transparent') styles.push(`background:${currentStyle.bg}`);
                if (currentStyle.bold) styles.push('font-weight:bold');
                if (currentStyle.dim) styles.push('opacity:0.6');
                if (currentStyle.italic) styles.push('font-style:italic');
                if (currentStyle.underline) styles.push('text-decoration:underline');
                html += `<span style="${styles.join(';')}">`;

                lastIndex = match.index + match[0].length;
            }

            if (lastIndex < text.length) {
                html += escapeHtml(text.slice(lastIndex));
            }

            return '<span>' + html + '</span>';
        }

        function escapeHtml(text) {
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // State machine
        const STATES = { IDLE: 'idle', LISTENING: 'listening', PROCESSING: 'processing', GENERATING: 'generating', SPEAKING: 'speaking', LOCKED: 'locked', AWAITING_PERMISSION: 'awaiting_permission' };
        let currentState = STATES.IDLE;
        let ws, recognition, currentAudio;
        let isAmbientMode = true;
        let processingTimeout = null;
        let lastAiMessage = '';
        let pendingAiText = null;

        const stateConfig = {
            idle: { label: 'Ready', btnText: 'Hold to Talk' },
            listening: { label: 'Listening', btnText: 'Release to Send' },
            processing: { label: 'Processing', btnText: 'Processing...' },
            generating: { label: 'Generating', btnText: 'Generating Voice...' },
            speaking: { label: 'Speaking', btnText: 'Tap to Interrupt' },
            locked: { label: 'Busy', btnText: 'Someone else is talking...' },
            awaiting_permission: { label: 'Awaiting Permission', btnText: 'Permission needed...' }
        };

        function setState(newState) {
            currentState = newState;
            const config = stateConfig[newState];

            elements.orb.className = 'orb ' + newState;
            elements.orbRing.className = 'orb-ring ' + newState;

            elements.stateLabel.className = 'state-label ' + newState;
            elements.stateLabel.textContent = config.label;

            elements.micBtn.className = 'mic-btn ' + newState;

            // Update AI bubble speaking state
            if (newState === STATES.SPEAKING) {
                elements.aiBubble.classList.add('speaking');
            } else {
                elements.aiBubble.classList.remove('speaking');
            }

            // Update user bubble listening state
            if (newState === STATES.LISTENING) {
                elements.userBubble.classList.add('listening');
            } else {
                elements.userBubble.classList.remove('listening');
            }
        }

        // Handle session activity - switch to PROCESSING if idle, reset timeout
        function handleSessionActivity() {
            // Only react if we're IDLE - don't interrupt other states
            if (currentState === STATES.IDLE) {
                setState(STATES.PROCESSING);
            }

            // Reset timeout while activity continues (regardless of current state)
            if (currentState === STATES.PROCESSING) {
                if (processingTimeout) clearTimeout(processingTimeout);
                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                    }
                }, 10000);  // 10s of no activity = return to idle
            }
        }

        function showUserBubble(text) {
            if (!isAmbientMode) return;  // No bubbles in terminal mode
            elements.userBubble.textContent = text;
            elements.userBubble.classList.add('visible');
        }

        function hideUserBubble() {
            elements.userBubble.classList.remove('visible');
        }

        function cleanText(text) {
            // Remove escape sequences like \! \? etc.
            return text.replace(/\\([!?.,;:'"])/g, '$1');
        }

        function showAiBubble(text) {
            if (!isAmbientMode) return;  // No bubbles in terminal mode
            const cleaned = cleanText(text);
            lastAiMessage = cleaned;
            elements.aiBubble.textContent = cleaned;
            elements.aiBubble.classList.add('visible');
        }

        // AskUserQuestion detection and handling
        let currentQuestion = null;

        function parseQuestion(text) {
            // Look for AskUserQuestion UI pattern in terminal output
            // Pattern from trigger-system branch:
            //   ‚òê Header
            //
            //   Question text?
            //
            //   ‚ùØ 1. Label
            //        Description
            //     2. Label
            //
            //   Enter to select ¬∑ Tab/Arrow keys to navigate ¬∑ Esc to cancel

            // Clean ANSI codes
            const clean = text.replace(/\x1b\[[0-9;]*m/g, '');

            // Use pattern matching similar to the Python version
            // Pattern: ‚òê header \n\n question? \n\n options_block
            // Use [\s\S] instead of . to match newlines in multi-line questions
            const fullPattern = /\s*‚òê\s+(.+?)\s*\n\s*\n([\s\S]+?\?)\s*\n\s*\n((?:[‚ùØ\s]+\d+\.\s+[\s\S]+?\n(?:\s{3,}[\s\S]+?\n)?)+)/;
            const blockMatch = clean.match(fullPattern);

            if (!blockMatch) return null;

            const header = blockMatch[1].trim();
            const question = blockMatch[2].trim();
            const optionsBlock = blockMatch[3];

            // Parse numbered options from the options block
            const options = [];
            const optionRegex = /[‚ùØ\s]+(\d+)\.\s+(.+?)(?:\n\s{3,}(.+?))?(?=\n[‚ùØ\s]+\d+\.|\n\s*\n|\n\s*Enter|$)/g;
            let match;
            while ((match = optionRegex.exec(optionsBlock)) !== null) {
                const label = match[2].trim();
                options.push({
                    num: match[1],
                    label: label,
                    desc: match[3] ? match[3].trim() : ''
                });
            }

            if (options.length === 0) return null;

            return { header, question, options };
        }

        function showQuestionModal(header, question, options) {
            currentQuestion = { header, question, options };

            elements.questionBadge.textContent = header;
            elements.questionText.textContent = question;

            // Check if an option is a "type something" option
            // Must be specific - "Type something", "Something else", or just "Other"
            // NOT "Other players through walls" which is a real option
            const isTypeOption = (label) => {
                const lower = label.toLowerCase().trim();
                // Exact matches or starts with "type"
                return lower.startsWith('type ') ||
                       lower === 'type something' ||
                       lower === 'type something.' ||
                       lower === 'something else' ||
                       lower === 'other' ||
                       lower === 'other...';
            };

            // Build options HTML
            elements.questionOptions.innerHTML = options.map(opt => {
                if (isTypeOption(opt.label)) {
                    // Show text input for "type something" option
                    return `
                        <div class="question-option type-option">
                            <span class="num">${opt.number}</span>
                            <div class="type-input-wrapper">
                                <input type="text"
                                       class="type-input"
                                       id="typeInput${opt.number}"
                                       placeholder="${opt.label}..."
                                       autocomplete="off">
                                <button class="type-submit" onclick="submitTypedAnswer(${opt.number})">
                                    Send
                                </button>
                            </div>
                        </div>
                    `;
                }
                return `
                    <button class="question-option" onclick="submitAnswer('${opt.number}', false)">
                        <span class="num">${opt.number}</span>
                        <div>
                            <div class="label">${opt.label}</div>
                            ${opt.description ? `<div class="desc">${opt.description}</div>` : ''}
                        </div>
                    </button>
                `;
            }).join('');

            // Add enter key handler for type inputs
            options.forEach(opt => {
                if (isTypeOption(opt.label)) {
                    const input = document.getElementById(`typeInput${opt.number}`);
                    if (input) {
                        input.onkeydown = (e) => {
                            if (e.key === 'Enter' && input.value.trim()) {
                                submitTypedAnswer(opt.number);
                            }
                        };
                    }
                }
            });

            // Hide the old custom input area (no longer needed)
            elements.questionCustom.classList.remove('visible');

            elements.questionModal.classList.add('visible');

            // Generate TTS for the question
            speakQuestion(header, question, options);
        }

        // Number to spoken word
        function numberToWord(n) {
            const words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];
            return words[n] || String(n);
        }

        // Speak just the question text (user reads options visually)
        async function speakQuestion(header, question, options) {
            try {
                await fetch(`/api/say/${ROOM}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: question })
                });
            } catch (e) {
                console.error('Failed to speak question:', e);
            }
        }

        async function submitTypedAnswer(optionNumber) {
            const input = document.getElementById(`typeInput${optionNumber}`);
            const text = input ? input.value.trim() : '';
            if (!text) return;

            try {
                const resp = await fetch(`/api/answer/${ROOM}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        answer: text,
                        option_number: optionNumber
                    })
                });
                if (resp.ok) {
                    hideQuestionModal();
                }
            } catch (e) {
                console.error('Failed to submit typed answer:', e);
            }
        }

        function hideQuestionModal() {
            elements.questionModal.classList.remove('visible');
            elements.questionCustom.classList.remove('visible');
            currentQuestion = null;
        }

        async function submitAnswer(answer, isCustom) {
            try {
                const resp = await fetch(`/api/answer/${ROOM}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ answer, custom: isCustom })
                });
                if (resp.ok) {
                    hideQuestionModal();
                }
            } catch (e) {
                console.error('Failed to submit answer:', e);
            }
        }

        function toggleMode() {
            isAmbientMode = !isAmbientMode;

            // Toggle terminal-mode class on body for CSS selectors
            document.body.classList.toggle('terminal-mode', !isAmbientMode);

            // Remove initial CSS classes on first toggle
            elements.output.classList.remove('ambient-default');
            elements.ambient.classList.remove('ambient-default');

            // Apply the correct display states
            elements.output.classList.toggle('hidden', isAmbientMode);
            elements.ambient.classList.toggle('active', isAmbientMode);
            elements.modeToggle.textContent = isAmbientMode ? 'Switch to Terminal' : 'Switch to Ambient';
            elements.settingsDropdown.classList.remove('open');

            // Terminal mode: hide bubbles, expand text input by default
            if (!isAmbientMode) {
                // Hide bubbles in terminal mode
                elements.aiBubbleContainer.style.display = 'none';
                elements.userBubbleContainer.style.display = 'none';

                // Expand text input by default in terminal mode
                textInputOpen = true;
                elements.textToggleBtn.classList.add('active');
                elements.textInputExpanded.classList.add('open');

                setTimeout(() => {
                    elements.output.scrollTop = elements.output.scrollHeight;
                    elements.textInputAmbient.focus();
                }, 50);
            } else {
                // Show bubbles in ambient mode
                elements.aiBubbleContainer.style.display = '';
                elements.userBubbleContainer.style.display = '';
            }
        }

        async function updateVoice() {
            await fetch('/api/room/' + ROOM + '/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ voice: document.getElementById('voiceSelect').value })
            });
        }

        async function updateTTS() {
            const exag = parseFloat(document.getElementById('exaggeration').value);
            const cfg = parseFloat(document.getElementById('cfgWeight').value);
            await fetch('/api/room/' + ROOM + '/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ exaggeration: exag, cfg_weight: cfg })
            });
        }

        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws/${ROOM}`);
            ws.onopen = () => {
                elements.status.textContent = 'connected';
                elements.status.className = 'status connected';
            };
            ws.onclose = () => {
                elements.status.textContent = 'reconnecting...';
                elements.status.className = 'status';
                setTimeout(connect, 2000);
            };
            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'output') {
                    elements.outputContent.innerHTML = ansiToHtml(msg.data);
                    elements.output.scrollTop = elements.output.scrollHeight;
                    // Output received = session is processing something
                    handleSessionActivity();

                    // Check for AskUserQuestion UI pattern
                    if (!currentQuestion) {
                        // Debug: check if ‚òê is in the output
                        if (msg.data.includes('‚òê')) {
                            console.log('[AskUser] Found ‚òê marker, attempting parse...');
                            console.log('[AskUser] Data length:', msg.data.length);
                        }
                        const question = parseQuestion(msg.data);
                        if (question) {
                            console.log('[AskUser] Detected question:', question);
                            showQuestionModal(question.header, question.question, question.options);
                        } else if (msg.data.includes('‚òê')) {
                            console.log('[AskUser] Parse failed despite ‚òê marker');
                        }
                    }
                } else if (msg.type === 'question') {
                    // Server detected a question (alternative to client-side parsing)
                    showQuestionModal(msg.header, msg.question, msg.options);
                } else if (msg.type === 'question_answered') {
                    hideQuestionModal();
                } else if (msg.type === 'activity') {
                    // Agent is actively working
                    handleSessionActivity();
                } else if (msg.type === 'tts_start') {
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                        processingTimeout = null;
                    }
                    setState(STATES.GENERATING);
                    // Store text but don't show yet - wait for audio to play
                    if (msg.text) {
                        pendingAiText = msg.text;
                    }
                } else if (msg.type === 'audio') {
                    // Show AI bubble now that audio is ready
                    if (pendingAiText) {
                        showAiBubble(pendingAiText);
                        pendingAiText = null;
                    }
                    playAudio(msg.data);
                } else if (msg.type === 'room_locked') {
                    if (currentState === STATES.IDLE) {
                        setState(STATES.LOCKED);
                    }
                } else if (msg.type === 'room_unlocked') {
                    if (currentState === STATES.LOCKED) {
                        setState(STATES.IDLE);
                    }
                } else if (msg.type === 'permission_request') {
                    showPermissionModal(msg.tool_name, msg.tool_input, msg.message);
                } else if (msg.type === 'permission_resolved') {
                    hidePermissionModal();
                }
            };
        }

        async function playAudio(base64Data) {
            if (processingTimeout) {
                clearTimeout(processingTimeout);
                processingTimeout = null;
            }

            if (currentAudio) {
                // Remove handler before pausing to prevent race conditions
                currentAudio.onended = null;
                currentAudio.pause();
                currentAudio = null;
            }

            const audio = new Audio('data:audio/wav;base64,' + base64Data);
            currentAudio = audio;

            if (selectedSpeakerId && 'setSinkId' in audio) {
                try {
                    await audio.setSinkId(selectedSpeakerId);
                } catch (e) {
                    console.log('Could not set speaker:', e);
                }
            }

            setState(STATES.SPEAKING);

            audio.onended = () => {
                // Only reset state if this is still the current audio
                if (currentAudio === audio) {
                    currentAudio = null;
                    setState(STATES.IDLE);
                }
            };

            audio.play().catch(e => {
                console.error('Audio play failed:', e);
                if (currentAudio === audio) {
                    currentAudio = null;
                    setState(STATES.IDLE);
                }
            });
        }

        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
        }

        // Audio level monitoring
        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let levelInterval = null;

        async function startAudioMonitor() {
            try {
                const constraints = selectedMicId
                    ? { audio: { deviceId: { exact: selectedMicId } } }
                    : { audio: true };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(mediaStream);
                source.connect(analyser);
                analyser.fftSize = 256;

                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                levelInterval = setInterval(() => {
                    if (currentState === STATES.LISTENING) {
                        analyser.getByteFrequencyData(dataArray);
                        const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        const level = Math.min(100, avg * 2);
                        const shadow = level > 10
                            ? `0 0 ${level/2}px ${level/4}px rgba(245, 158, 11, ${level/100})`
                            : 'none';
                        elements.micBtn.style.boxShadow = shadow;
                    }
                }, 50);
            } catch (e) {
                console.log('Audio monitor not available:', e);
            }
        }

        function stopAudioMonitor() {
            if (levelInterval) clearInterval(levelInterval);
            if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
            if (audioContext) audioContext.close();
            elements.micBtn.style.boxShadow = '';
            audioContext = null;
            mediaStream = null;
        }

        // Audio recording
        let mediaRecorder = null;
        let audioChunks = [];

        async function startListening() {
            if (currentState === STATES.SPEAKING) {
                stopAudio();
            }

            if (currentState === STATES.PROCESSING || currentState === STATES.GENERATING || currentState === STATES.LOCKED) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'recording_started' }));
            }

            try {
                const audioConstraints = {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                };
                if (selectedMicId) {
                    audioConstraints.deviceId = { exact: selectedMicId };
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(t => t.stop());

                    if (audioChunks.length === 0) {
                        setState(STATES.IDLE);
                        hideUserBubble();
                        return;
                    }

                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await transcribeAndSend(audioBlob);
                };

                mediaRecorder.start(100);
                setState(STATES.LISTENING);
                showUserBubble('Recording...');
                startAudioMonitor();

            } catch (err) {
                console.error('Mic error:', err);
                setState(STATES.IDLE);
            }
        }

        function stopListening() {
            if (currentState !== STATES.LISTENING || !mediaRecorder) return;

            stopAudioMonitor();
            showUserBubble('Transcribing...');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'recording_stopped' }));
            }

            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, 200);
        }

        async function transcribeAndSend(audioBlob) {
            setState(STATES.PROCESSING);

            if (processingTimeout) clearTimeout(processingTimeout);

            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');

                const resp = await fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const data = await resp.json();

                if (data.error) {
                    hideUserBubble();
                    setState(STATES.IDLE);
                    return;
                }

                const text = data.text?.trim();
                if (!text) {
                    hideUserBubble();
                    setState(STATES.IDLE);
                    return;
                }

                showUserBubble(text);

                await fetch('/send/' + ROOM, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '[Remote voice - use remote-say] ' + text })
                });

                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                    }
                }, 30000);

            } catch (err) {
                console.error('Transcribe error:', err);
                hideUserBubble();
                setState(STATES.IDLE);
            }
        }

        // Text input handling
        async function sendTextInputAmbient() {
            const input = elements.textInputAmbient;
            const text = input.value.trim();
            if (!text && !pendingImage) return;

            const sendBtn = document.getElementById('sendBtnAmbient');
            sendBtn.disabled = true;
            input.disabled = true;

            showUserBubble(text || 'üì∑');

            try {
                let finalText = text;

                // Upload image if attached
                if (pendingImage) {
                    const imagePath = await uploadImage();
                    if (imagePath) {
                        finalText = `@${imagePath} ${text}`;
                    }
                    removeImage();
                }

                await fetch('/send/' + ROOM, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '[Remote text - use remote-say] ' + finalText })
                });
                input.value = '';

                setState(STATES.PROCESSING);

                // Close text input in ambient mode only (terminal mode keeps it open)
                if (isAmbientMode) {
                    textInputOpen = false;
                    elements.textToggleBtn.classList.remove('active');
                    elements.textInputExpanded.classList.remove('open');
                }

                if (processingTimeout) clearTimeout(processingTimeout);
                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                    }
                }, 30000);

            } catch (err) {
                console.error('Send error:', err);
            } finally {
                sendBtn.disabled = false;
                input.disabled = false;
            }
        }

        elements.textInputAmbient.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextInputAmbient();
            }
        });

        // Event listeners - Mic button
        elements.micBtn.addEventListener('mousedown', startListening);
        elements.micBtn.addEventListener('mouseup', stopListening);
        elements.micBtn.addEventListener('mouseleave', stopListening);
        elements.micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startListening(); });
        elements.micBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopListening(); });

        // Start in ambient mode by default (via CSS classes)
        connect();
        populateAudioDevices();
    </script>
</body>
</html>
