<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="icon" type="image/jpeg" href="/static/favicon-green.jpeg">
    <title>{{ room_name }} - AgentWire</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            /* Layout */
            --header-height: 52px;
            --tts-height: 40px;
            --controls-height: 190px;

            /* Theme colors - Electric Green */
            --primary: #00DD00;
            --primary-dim: #00BB00;
            --primary-dark: #009900;
            --primary-glow: rgba(0, 221, 0, 0.4);
            --primary-subtle: rgba(0, 221, 0, 0.15);

            /* Backgrounds */
            --bg-dark: #000;
            --bg-mid: #0a0a0a;
            --bg-light: #111;
            --bg-elevated: #1a1a1a;

            /* Text */
            --text-primary: #E8EEF2;
            --text-secondary: #8899A6;
            --text-muted: #5C6B7A;

            /* Borders */
            --border: #2A3A4D;
            --border-light: #3D4F63;

            /* States - semantic colors */
            --success: #4ADE80;
            --warning: #FBBF24;
            --error: #F87171;
            --info: var(--primary);

            /* Orb states */
            --orb-idle: var(--primary);
            --orb-idle-dark: var(--primary-dark);
            --orb-listening: #FBBF24;
            --orb-listening-dark: #D97706;
            --orb-processing: #A855F7;
            --orb-processing-dark: #7C3AED;
            --orb-generating: #3B82F6;
            --orb-generating-dark: #1D4ED8;
            --orb-speaking: #4ADE80;
            --orb-speaking-dark: #22C55E;
        }
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .header {
            height: var(--header-height);
            padding: 0 1rem;
            background: #000;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .header h1 { font-size: 1.1rem; color: var(--text-secondary); }
        .header a { color: var(--text-muted); text-decoration: none; font-size: 0.9rem; }
        .header-brand { color: var(--primary); font-weight: 600; font-size: 0.9rem; margin-right: 0.75rem; text-decoration: none; display: flex; align-items: center; gap: 0.4rem; }
        .header-logo { width: 24px; height: 24px; border-radius: 4px; }
        .header-left { display: flex; align-items: center; }
        .header-right { display: flex; align-items: center; gap: 0.75rem; }
        .settings-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        .settings-btn:hover { color: var(--primary); }
        .settings-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-light);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 0.75rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .settings-dropdown.open { display: flex; }
        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        .settings-group label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .settings-group select, .settings-group button {
            padding: 0.4rem 0.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
            width: 100%;
            text-align: left;
        }
        .settings-group select:hover, .settings-group button:hover {
            border-color: var(--primary);
        }
        .header-right { position: relative; }
        .status { font-size: 0.7rem; color: var(--text-muted); }
        .status.connected { color: var(--primary); }
        .tts-controls {
            display: none;
            height: var(--tts-height);
            gap: 1rem;
            padding: 0 1rem;
            background: #000;
            border-bottom: 1px solid var(--border);
            align-items: center;
            flex-shrink: 0;
        }
        .tts-controls.visible { display: flex; }
        .tts-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .tts-control input[type="range"] { width: 60px; accent-color: var(--primary); }

        /* Terminal mode */
        .output {
            flex: 1;
            padding: 1rem;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            font-family: ui-monospace, monospace;
            font-size: 0.8rem;
            background: var(--bg-dark);
            color: var(--text-secondary);
            min-height: 0;
        }
        .output-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Ambient mode container */
        .ambient {
            flex: 1;
            display: none;
            flex-direction: column;
            background: var(--bg-dark);
            min-height: 0;
            position: relative;
        }
        .ambient.active { display: flex; }
        .output.hidden { display: none; }

        /* AI Speech bubble - top */
        .ai-bubble-container {
            padding: 1rem;
            padding-bottom: 0;
        }
        .ai-bubble {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 16px;
            border-top-left-radius: 4px;
            padding: 0.875rem 1rem;
            font-size: 1rem;
            line-height: 1.4;
            color: var(--text-primary);
            max-width: 85%;
            position: relative;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }
        .ai-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .ai-bubble.speaking {
            border-color: var(--orb-speaking);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.2);
        }
        .ai-bubble::before {
            content: 'ðŸ¤–';
            position: absolute;
            top: -0.5rem;
            left: -0.5rem;
            font-size: 0.9rem;
        }

        /* Orb area - center */
        .orb-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
        }

        /* State label */
        .state-label {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        .state-label.idle { color: var(--orb-idle); }
        .state-label.listening { color: var(--orb-listening); }
        .state-label.processing { color: var(--orb-processing); }
        .state-label.generating { color: var(--orb-generating); }
        .state-label.speaking { color: var(--orb-speaking); }

        /* Orb container */
        .orb-container {
            position: relative;
            width: min(40vw, 40vh, 220px);
            height: min(40vw, 40vh, 220px);
        }
        .orb {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .orb-ring {
            position: absolute;
            inset: -10%;
            border-radius: 50%;
            border: 2px solid var(--primary-subtle);
            transition: all 0.3s ease;
        }

        /* Orb states */
        .orb.idle {
            background: radial-gradient(circle at 30% 30%, var(--orb-idle), var(--orb-idle-dark));
            animation: breathe 4s ease-in-out infinite;
            box-shadow: 0 0 60px var(--primary-glow);
        }
        .orb-ring.idle {
            animation: ring-breathe 4s ease-in-out infinite;
            border-color: var(--primary-subtle);
        }
        .orb.listening {
            background: radial-gradient(circle at 30% 30%, var(--orb-listening), var(--orb-listening-dark));
            animation: listen 0.8s ease-in-out infinite;
            box-shadow: 0 0 80px rgba(245, 158, 11, 0.4);
        }
        .orb-ring.listening {
            animation: ring-listen 0.8s ease-in-out infinite;
            border-color: rgba(245, 158, 11, 0.4);
        }
        .orb.processing {
            background: conic-gradient(from 0deg, var(--orb-processing), var(--orb-processing-dark), var(--orb-processing));
            animation: spin 1.5s linear infinite, pulse-processing 0.8s ease-in-out infinite;
            box-shadow: 0 0 60px rgba(168, 85, 247, 0.4);
        }
        .orb-ring.processing {
            animation: ring-spin 3s linear infinite reverse;
            border-color: rgba(168, 85, 247, 0.4);
            border-width: 3px;
            border-style: dashed;
        }
        .orb.generating {
            background: radial-gradient(circle at 30% 30%, var(--orb-generating), var(--orb-generating-dark));
            animation: generate 0.6s ease-in-out infinite;
            box-shadow: 0 0 80px rgba(56, 189, 248, 0.5);
        }
        .orb-ring.generating {
            animation: ring-generate 0.6s ease-in-out infinite;
            border-color: rgba(56, 189, 248, 0.5);
            border-width: 3px;
        }
        .orb.speaking {
            background: radial-gradient(circle at 30% 30%, var(--orb-speaking), var(--orb-speaking-dark));
            animation: speak 0.25s ease-in-out infinite;
            box-shadow: 0 0 100px rgba(45, 212, 191, 0.5);
        }
        .orb-ring.speaking {
            animation: ring-speak 0.4s ease-in-out infinite;
            border-color: rgba(45, 212, 191, 0.5);
            border-width: 3px;
        }
        .orb.locked {
            background: radial-gradient(circle at 30% 30%, var(--text-muted), var(--bg-elevated));
            animation: breathe 4s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(92, 107, 122, 0.3);
            opacity: 0.6;
        }
        .orb-ring.locked {
            animation: ring-breathe 4s ease-in-out infinite;
            border-color: rgba(92, 107, 122, 0.3);
        }
        .state-label.locked { color: var(--text-secondary); }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.03); opacity: 1; }
        }
        @keyframes ring-breathe {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.05); opacity: 0.5; }
        }
        @keyframes listen {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        @keyframes ring-listen {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.15); opacity: 0.7; }
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes pulse-processing {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        @keyframes ring-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes generate {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.06); opacity: 1; }
        }
        @keyframes ring-generate {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.12); opacity: 0.8; }
        }
        @keyframes speak {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.12); }
        }
        @keyframes ring-speak {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.9; }
        }

        /* User bubble - bottom, above floating controls */
        .user-bubble-container {
            padding: 0 1rem;
            padding-bottom: 100px; /* Space for floating controls */
        }
        .user-bubble {
            background: var(--primary-subtle);
            border: 1px solid rgba(0, 221, 0, 0.3);
            border-radius: 16px;
            border-bottom-right-radius: 4px;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            line-height: 1.3;
            color: var(--text-primary);
            max-width: 85%;
            margin-left: auto;
            position: relative;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }
        .user-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .user-bubble.listening {
            border-color: var(--orb-listening);
            background: rgba(245, 158, 11, 0.15);
        }
        .user-bubble::after {
            content: 'ðŸ‘¤';
            position: absolute;
            bottom: -0.5rem;
            right: -0.5rem;
            font-size: 0.8rem;
        }

        /* Floating controls container */
        .floating-controls {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 50;
        }
        .floating-controls > * {
            pointer-events: auto;
        }

        /* Text input - left side */
        .text-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .text-toggle-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .text-toggle-btn:hover {
            border-color: var(--primary);
            color: var(--primary);
        }
        .text-toggle-btn.active {
            background: var(--primary-subtle);
            border-color: var(--primary);
            color: var(--primary);
        }
        .text-input-expanded {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 28px;
            padding: 0.25rem 0.5rem 0.25rem 1rem;
            max-width: 0;
            overflow: hidden;
            opacity: 0;
            transition: all 0.3s ease;
        }
        .text-input-expanded.open {
            max-width: 280px;
            opacity: 1;
        }
        .text-input-expanded input {
            flex: 1;
            min-width: 0;
            width: 180px;
            padding: 0.5rem 0;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        .text-input-expanded input:focus {
            outline: none;
        }
        .text-input-expanded input::placeholder {
            color: var(--text-muted);
        }
        .send-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary);
            border: none;
            color: #000;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .send-btn:hover {
            background: var(--primary-dim);
            transform: scale(1.05);
        }
        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Mic button - right side */
        .mic-btn {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
        }
        .mic-btn.idle {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: #000;
            box-shadow: 0 4px 20px var(--primary-glow);
        }
        .mic-btn.listening {
            background: linear-gradient(135deg, var(--orb-listening), var(--orb-listening-dark));
            color: #000;
            animation: mic-pulse 0.8s ease-in-out infinite;
            box-shadow: 0 4px 30px rgba(245, 158, 11, 0.5);
        }
        .mic-btn.processing {
            background: linear-gradient(135deg, var(--orb-processing), var(--orb-processing-dark));
            color: #fff;
            cursor: not-allowed;
            opacity: 0.8;
        }
        .mic-btn.generating {
            background: linear-gradient(135deg, var(--orb-generating), var(--orb-generating-dark));
            color: #fff;
            cursor: not-allowed;
            animation: mic-pulse 0.6s ease-in-out infinite;
        }
        .mic-btn.speaking {
            background: linear-gradient(135deg, var(--orb-speaking), var(--orb-speaking-dark));
            color: #000;
        }
        .mic-btn.locked {
            background: linear-gradient(135deg, var(--bg-elevated), var(--bg-light));
            color: var(--text-muted);
            cursor: not-allowed;
            opacity: 0.6;
        }
        @keyframes mic-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        /* Terminal mode controls */
        .controls {
            height: var(--controls-height);
            padding: 1rem;
            background: #000;
            border-top: 1px solid var(--border);
            flex-shrink: 0;
            margin-top: auto;
        }
        .controls .transcript {
            margin-bottom: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-light);
            border-radius: 8px;
            font-size: 1rem;
            min-height: 1.5rem;
            max-height: 3rem;
            overflow-y: auto;
            color: var(--text-primary);
            text-align: center;
            line-height: 1.3;
        }
        .controls .mic-btn-terminal {
            width: 100%;
            padding: 1.25rem;
            font-size: 1.1rem;
            font-weight: 500;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .controls .mic-btn-terminal.idle {
            background: linear-gradient(135deg, rgba(0, 221, 0, 0.15), rgba(0, 153, 0, 0.15));
            color: var(--primary);
            border: 2px solid rgba(0, 221, 0, 0.3);
        }
        .controls .mic-btn-terminal.listening {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(180, 83, 9, 0.15));
            color: var(--orb-listening);
            border: 2px solid rgba(245, 158, 11, 0.4);
            animation: btn-pulse 0.8s ease-in-out infinite;
        }
        .controls .mic-btn-terminal.processing,
        .controls .mic-btn-terminal.generating {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(124, 58, 237, 0.15));
            color: var(--orb-processing);
            border: 2px solid rgba(168, 85, 247, 0.3);
            cursor: not-allowed;
            opacity: 0.7;
        }
        .controls .mic-btn-terminal.speaking {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.15), rgba(34, 197, 94, 0.15));
            color: var(--orb-speaking);
            border: 2px solid rgba(74, 222, 128, 0.3);
        }
        @keyframes btn-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(0.98); }
        }
        .controls .text-input-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .controls .text-input {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        .controls .text-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .controls .text-input::placeholder {
            color: var(--text-muted);
        }
        .controls .send-btn-terminal {
            padding: 0.75rem 1rem;
            background: var(--primary-subtle);
            border: 1px solid rgba(0, 221, 0, 0.3);
            border-radius: 8px;
            color: var(--primary);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .controls .send-btn-terminal:hover {
            background: rgba(0, 221, 0, 0.25);
            border-color: var(--primary);
        }
        .controls .send-btn-terminal:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <a href="/" class="header-brand"><img src="/static/logo-green.jpeg" alt="" class="header-logo">AgentWire</a>
            <div>
                <h1>{{ room_name }}{% if config.machine %}<span style="color:var(--text-muted);font-weight:normal">@{{ config.machine }}</span>{% endif %}</h1>
                <div class="status" id="status">connecting...</div>
            </div>
        </div>
        <div class="header-right">
            <button class="settings-btn" id="settingsBtn" onclick="toggleSettings()" title="Settings">âš™</button>
            <div class="settings-dropdown" id="settingsDropdown">
                <div class="settings-group">
                    <label>View</label>
                    <button id="modeToggle" onclick="toggleMode()">Switch to Terminal</button>
                </div>
                <div class="settings-group">
                    <label>Microphone</label>
                    <select id="micSelect" onchange="updateMic()">
                        <option value="">Default Mic</option>
                    </select>
                </div>
                <div class="settings-group">
                    <label>Speaker</label>
                    <select id="speakerSelect" onchange="updateSpeaker()">
                        <option value="">Default Speaker</option>
                    </select>
                </div>
                <div class="settings-group">
                    <label>TTS Voice</label>
                    <select id="voiceSelect" onchange="updateVoice()">
                        {% for voice in voices %}
                        <option value="{{ voice }}"{% if voice == current_voice %} selected{% endif %}>{{ voice }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
        </div>
    </div>
    <div class="tts-controls" id="ttsControls">
        <div class="tts-control">
            <label>Exag</label>
            <input type="range" id="exaggeration" min="0" max="1" step="0.1" value="{{ config.exaggeration }}" onchange="updateTTS()">
            <span id="exagVal">{{ config.exaggeration }}</span>
        </div>
        <div class="tts-control">
            <label>CFG</label>
            <input type="range" id="cfgWeight" min="0" max="1" step="0.1" value="{{ config.cfg_weight }}" onchange="updateTTS()">
            <span id="cfgVal">{{ config.cfg_weight }}</span>
        </div>
    </div>

    <!-- Terminal Mode -->
    <div class="output" id="output"><div class="output-content" id="outputContent"></div></div>

    <!-- Ambient Mode -->
    <div class="ambient" id="ambient">
        <!-- AI message at top -->
        <div class="ai-bubble-container">
            <div class="ai-bubble" id="aiBubble"></div>
        </div>

        <!-- Orb in center -->
        <div class="orb-area">
            <div class="state-label idle" id="stateLabel">Ready</div>
            <div class="orb-container">
                <div class="orb-ring idle" id="orbRing"></div>
                <div class="orb idle" id="orb"></div>
            </div>
        </div>

        <!-- User message bubble -->
        <div class="user-bubble-container">
            <div class="user-bubble" id="userBubble"></div>
        </div>

        <!-- Floating controls -->
        <div class="floating-controls">
            <!-- Text input on left -->
            <div class="text-input-wrapper">
                <button class="text-toggle-btn" id="textToggleBtn" onclick="toggleTextInput()">âŒ¨</button>
                <div class="text-input-expanded" id="textInputExpanded">
                    <input type="text" id="textInputAmbient" placeholder="Type a message..." autocomplete="off">
                    <button class="send-btn" id="sendBtnAmbient" onclick="sendTextInputAmbient()">â†‘</button>
                </div>
            </div>

            <!-- Mic button on right -->
            <button class="mic-btn idle" id="micBtn">ðŸŽ¤</button>
        </div>
    </div>

    <!-- Terminal Mode Controls -->
    <div class="controls" id="terminalControls">
        <div class="transcript" id="transcript">Tap and hold to speak</div>
        <button class="mic-btn-terminal idle" id="micBtnTerminal">Hold to Talk</button>
        <div class="text-input-row">
            <input type="text" class="text-input" id="textInput" placeholder="Type a message..." autocomplete="off">
            <button class="send-btn-terminal" id="sendBtn" onclick="sendTextInput()">â†µ</button>
        </div>
    </div>

    <script>
        const ROOM = '{{ room_name }}';
        const elements = {
            output: document.getElementById('output'),
            outputContent: document.getElementById('outputContent'),
            ambient: document.getElementById('ambient'),
            orb: document.getElementById('orb'),
            orbRing: document.getElementById('orbRing'),
            stateLabel: document.getElementById('stateLabel'),
            status: document.getElementById('status'),
            micBtn: document.getElementById('micBtn'),
            micBtnTerminal: document.getElementById('micBtnTerminal'),
            transcript: document.getElementById('transcript'),
            modeToggle: document.getElementById('modeToggle'),
            ttsControls: document.getElementById('ttsControls'),
            terminalControls: document.getElementById('terminalControls'),
            micSelect: document.getElementById('micSelect'),
            speakerSelect: document.getElementById('speakerSelect'),
            settingsDropdown: document.getElementById('settingsDropdown'),
            aiBubble: document.getElementById('aiBubble'),
            userBubble: document.getElementById('userBubble'),
            textToggleBtn: document.getElementById('textToggleBtn'),
            textInputExpanded: document.getElementById('textInputExpanded'),
            textInputAmbient: document.getElementById('textInputAmbient')
        };

        let textInputOpen = false;

        function toggleTextInput() {
            textInputOpen = !textInputOpen;
            elements.textToggleBtn.classList.toggle('active', textInputOpen);
            elements.textInputExpanded.classList.toggle('open', textInputOpen);
            if (textInputOpen) {
                setTimeout(() => elements.textInputAmbient.focus(), 100);
            }
        }

        function toggleSettings() {
            elements.settingsDropdown.classList.toggle('open');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.header-right')) {
                elements.settingsDropdown.classList.remove('open');
            }
        });

        // Audio device selection
        let selectedMicId = localStorage.getItem('agentwire-mic-id') || '';
        let selectedSpeakerId = localStorage.getItem('agentwire-speaker-id') || '';

        async function populateAudioDevices() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => stream.getTracks().forEach(t => t.stop()));

                const devices = await navigator.mediaDevices.enumerateDevices();

                const mics = devices.filter(d => d.kind === 'audioinput');
                elements.micSelect.innerHTML = '<option value="">Default Mic</option>';
                mics.forEach(mic => {
                    const opt = document.createElement('option');
                    opt.value = mic.deviceId;
                    opt.textContent = mic.label || `Microphone ${mic.deviceId.slice(0, 8)}`;
                    if (mic.deviceId === selectedMicId) opt.selected = true;
                    elements.micSelect.appendChild(opt);
                });

                const speakers = devices.filter(d => d.kind === 'audiooutput');
                elements.speakerSelect.innerHTML = '<option value="">Default Speaker</option>';
                speakers.forEach(speaker => {
                    const opt = document.createElement('option');
                    opt.value = speaker.deviceId;
                    opt.textContent = speaker.label || `Speaker ${speaker.deviceId.slice(0, 8)}`;
                    if (speaker.deviceId === selectedSpeakerId) opt.selected = true;
                    elements.speakerSelect.appendChild(opt);
                });

                if (!('setSinkId' in HTMLAudioElement.prototype)) {
                    elements.speakerSelect.style.display = 'none';
                }
            } catch (e) {
                console.log('Could not enumerate audio devices:', e);
            }
        }

        function updateMic() {
            selectedMicId = elements.micSelect.value;
            localStorage.setItem('agentwire-mic-id', selectedMicId);
        }

        function updateSpeaker() {
            selectedSpeakerId = elements.speakerSelect.value;
            localStorage.setItem('agentwire-speaker-id', selectedSpeakerId);
        }

        // ANSI to HTML converter
        function ansiToHtml(text) {
            const colors = {
                '30': '#000', '31': '#e55', '32': '#5e5', '33': '#ee5',
                '34': '#55e', '35': '#e5e', '36': '#5ee', '37': '#eee',
                '90': '#888', '91': '#f88', '92': '#8f8', '93': '#ff8',
                '94': '#88f', '95': '#f8f', '96': '#8ff', '97': '#fff',
                '39': '#aaa'
            };
            const bgColors = {
                '40': '#000', '41': '#a00', '42': '#0a0', '43': '#a50',
                '44': '#00a', '45': '#a0a', '46': '#0aa', '47': '#aaa',
                '49': 'transparent'
            };

            let html = '';
            let currentStyle = {};
            const regex = /\x1b\[([0-9;]*)m/g;
            let lastIndex = 0;
            let match;

            while ((match = regex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    const chunk = text.slice(lastIndex, match.index);
                    html += escapeHtml(chunk);
                }

                const codes = match[1].split(';').filter(c => c !== '');
                for (const code of codes) {
                    if (code === '0' || code === '') {
                        currentStyle = {};
                    } else if (code === '1') {
                        currentStyle.bold = true;
                    } else if (code === '2') {
                        currentStyle.dim = true;
                    } else if (code === '3') {
                        currentStyle.italic = true;
                    } else if (code === '4') {
                        currentStyle.underline = true;
                    } else if (colors[code]) {
                        currentStyle.color = colors[code];
                    } else if (bgColors[code]) {
                        currentStyle.bg = bgColors[code];
                    }
                }

                html += '</span>';
                const styles = [];
                if (currentStyle.color) styles.push(`color:${currentStyle.color}`);
                if (currentStyle.bg && currentStyle.bg !== 'transparent') styles.push(`background:${currentStyle.bg}`);
                if (currentStyle.bold) styles.push('font-weight:bold');
                if (currentStyle.dim) styles.push('opacity:0.6');
                if (currentStyle.italic) styles.push('font-style:italic');
                if (currentStyle.underline) styles.push('text-decoration:underline');
                html += `<span style="${styles.join(';')}">`;

                lastIndex = match.index + match[0].length;
            }

            if (lastIndex < text.length) {
                html += escapeHtml(text.slice(lastIndex));
            }

            return '<span>' + html + '</span>';
        }

        function escapeHtml(text) {
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // State machine
        const STATES = { IDLE: 'idle', LISTENING: 'listening', PROCESSING: 'processing', GENERATING: 'generating', SPEAKING: 'speaking', LOCKED: 'locked' };
        let currentState = STATES.IDLE;
        let ws, recognition, currentAudio;
        let isAmbientMode = false;
        let processingTimeout = null;
        let lastAiMessage = '';
        let pendingAiText = null;

        const stateConfig = {
            idle: { label: 'Ready', btnText: 'Hold to Talk' },
            listening: { label: 'Listening', btnText: 'Release to Send' },
            processing: { label: 'Thinking', btnText: 'Processing...' },
            generating: { label: 'Generating', btnText: 'Generating Voice...' },
            speaking: { label: 'Speaking', btnText: 'Tap to Interrupt' },
            locked: { label: 'Busy', btnText: 'Someone else is talking...' }
        };

        function setState(newState) {
            currentState = newState;
            const config = stateConfig[newState];

            elements.orb.className = 'orb ' + newState;
            elements.orbRing.className = 'orb-ring ' + newState;

            elements.stateLabel.className = 'state-label ' + newState;
            elements.stateLabel.textContent = config.label;

            elements.micBtn.className = 'mic-btn ' + newState;
            elements.micBtnTerminal.className = 'mic-btn-terminal ' + newState;
            elements.micBtnTerminal.textContent = config.btnText;

            // Update AI bubble speaking state
            if (newState === STATES.SPEAKING) {
                elements.aiBubble.classList.add('speaking');
            } else {
                elements.aiBubble.classList.remove('speaking');
            }

            // Update user bubble listening state
            if (newState === STATES.LISTENING) {
                elements.userBubble.classList.add('listening');
            } else {
                elements.userBubble.classList.remove('listening');
            }
        }

        function showUserBubble(text) {
            elements.userBubble.textContent = text;
            elements.userBubble.classList.add('visible');
        }

        function hideUserBubble() {
            elements.userBubble.classList.remove('visible');
        }

        function cleanText(text) {
            // Remove escape sequences like \! \? etc.
            return text.replace(/\\([!?.,;:'"])/g, '$1');
        }

        function showAiBubble(text) {
            const cleaned = cleanText(text);
            lastAiMessage = cleaned;
            elements.aiBubble.textContent = cleaned;
            elements.aiBubble.classList.add('visible');
        }

        function toggleMode() {
            isAmbientMode = !isAmbientMode;
            elements.output.classList.toggle('hidden', isAmbientMode);
            elements.ambient.classList.toggle('active', isAmbientMode);
            elements.ttsControls.classList.toggle('visible', !isAmbientMode);
            elements.terminalControls.style.display = isAmbientMode ? 'none' : 'block';
            elements.modeToggle.textContent = isAmbientMode ? 'Switch to Terminal' : 'Switch to Ambient';
            elements.settingsDropdown.classList.remove('open');

            if (!isAmbientMode) {
                setTimeout(() => {
                    elements.output.scrollTop = elements.output.scrollHeight;
                }, 50);
            }
        }

        async function updateVoice() {
            await fetch('/api/room/' + ROOM + '/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ voice: document.getElementById('voiceSelect').value })
            });
        }

        async function updateTTS() {
            const exag = parseFloat(document.getElementById('exaggeration').value);
            const cfg = parseFloat(document.getElementById('cfgWeight').value);
            document.getElementById('exagVal').textContent = exag.toFixed(1);
            document.getElementById('cfgVal').textContent = cfg.toFixed(1);
            await fetch('/api/room/' + ROOM + '/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ exaggeration: exag, cfg_weight: cfg })
            });
        }

        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws/${ROOM}`);
            ws.onopen = () => {
                elements.status.textContent = 'connected';
                elements.status.className = 'status connected';
            };
            ws.onclose = () => {
                elements.status.textContent = 'reconnecting...';
                elements.status.className = 'status';
                setTimeout(connect, 2000);
            };
            ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'output') {
                    elements.outputContent.innerHTML = ansiToHtml(msg.data);
                    elements.output.scrollTop = elements.output.scrollHeight;
                } else if (msg.type === 'tts_start') {
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                        processingTimeout = null;
                    }
                    setState(STATES.GENERATING);
                    // Store text but don't show yet - wait for audio to play
                    if (msg.text) {
                        pendingAiText = msg.text;
                    }
                } else if (msg.type === 'audio') {
                    // Show AI bubble now that audio is ready
                    if (pendingAiText) {
                        showAiBubble(pendingAiText);
                        pendingAiText = null;
                    }
                    playAudio(msg.data);
                } else if (msg.type === 'room_locked') {
                    if (currentState === STATES.IDLE) {
                        setState(STATES.LOCKED);
                        elements.transcript.textContent = 'Another device is talking...';
                    }
                } else if (msg.type === 'room_unlocked') {
                    if (currentState === STATES.LOCKED) {
                        setState(STATES.IDLE);
                        elements.transcript.textContent = 'Tap and hold to speak';
                    }
                }
            };
        }

        async function playAudio(base64Data) {
            if (processingTimeout) {
                clearTimeout(processingTimeout);
                processingTimeout = null;
            }

            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            currentAudio = new Audio('data:audio/wav;base64,' + base64Data);

            if (selectedSpeakerId && 'setSinkId' in currentAudio) {
                try {
                    await currentAudio.setSinkId(selectedSpeakerId);
                } catch (e) {
                    console.log('Could not set speaker:', e);
                }
            }

            setState(STATES.SPEAKING);

            currentAudio.onended = () => {
                currentAudio = null;
                setState(STATES.IDLE);
                elements.transcript.textContent = 'Tap and hold to speak';
            };

            currentAudio.play().catch(e => {
                console.error('Audio play failed:', e);
                currentAudio = null;
                setState(STATES.IDLE);
            });
        }

        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
        }

        // Audio level monitoring
        let audioContext = null;
        let analyser = null;
        let mediaStream = null;
        let levelInterval = null;

        async function startAudioMonitor() {
            try {
                const constraints = selectedMicId
                    ? { audio: { deviceId: { exact: selectedMicId } } }
                    : { audio: true };
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(mediaStream);
                source.connect(analyser);
                analyser.fftSize = 256;

                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                levelInterval = setInterval(() => {
                    if (currentState === STATES.LISTENING) {
                        analyser.getByteFrequencyData(dataArray);
                        const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        const level = Math.min(100, avg * 2);
                        const shadow = level > 10
                            ? `0 0 ${level/2}px ${level/4}px rgba(245, 158, 11, ${level/100})`
                            : 'none';
                        elements.micBtn.style.boxShadow = shadow;
                        elements.micBtnTerminal.style.boxShadow = shadow;
                    }
                }, 50);
            } catch (e) {
                console.log('Audio monitor not available:', e);
            }
        }

        function stopAudioMonitor() {
            if (levelInterval) clearInterval(levelInterval);
            if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());
            if (audioContext) audioContext.close();
            elements.micBtn.style.boxShadow = '';
            elements.micBtnTerminal.style.boxShadow = 'none';
            audioContext = null;
            mediaStream = null;
        }

        // Audio recording
        let mediaRecorder = null;
        let audioChunks = [];

        async function startListening() {
            if (currentState === STATES.SPEAKING) {
                stopAudio();
            }

            if (currentState === STATES.PROCESSING || currentState === STATES.GENERATING || currentState === STATES.LOCKED) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'recording_started' }));
            }

            try {
                const audioConstraints = {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                };
                if (selectedMicId) {
                    audioConstraints.deviceId = { exact: selectedMicId };
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });

                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(t => t.stop());

                    if (audioChunks.length === 0) {
                        setState(STATES.IDLE);
                        elements.transcript.textContent = 'Tap and hold to speak';
                        hideUserBubble();
                        return;
                    }

                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    await transcribeAndSend(audioBlob);
                };

                mediaRecorder.start(100);
                setState(STATES.LISTENING);
                elements.transcript.textContent = 'Recording...';
                showUserBubble('Recording...');
                startAudioMonitor();

            } catch (err) {
                console.error('Mic error:', err);
                elements.transcript.textContent = 'Microphone error';
                setState(STATES.IDLE);
            }
        }

        function stopListening() {
            if (currentState !== STATES.LISTENING || !mediaRecorder) return;

            stopAudioMonitor();
            elements.transcript.textContent = 'Transcribing...';
            showUserBubble('Transcribing...');

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'recording_stopped' }));
            }

            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, 200);
        }

        async function transcribeAndSend(audioBlob) {
            setState(STATES.PROCESSING);

            if (processingTimeout) clearTimeout(processingTimeout);

            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');

                const resp = await fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const data = await resp.json();

                if (data.error) {
                    elements.transcript.textContent = 'Transcription failed';
                    hideUserBubble();
                    setState(STATES.IDLE);
                    return;
                }

                const text = data.text?.trim();
                if (!text) {
                    elements.transcript.textContent = 'No speech detected';
                    hideUserBubble();
                    setState(STATES.IDLE);
                    return;
                }

                elements.transcript.textContent = text;
                showUserBubble(text);

                await fetch('/send/' + ROOM, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '[Remote voice - use remote-say] ' + text })
                });

                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                        elements.transcript.textContent = 'Tap and hold to speak';
                    }
                }, 30000);

            } catch (err) {
                console.error('Transcribe error:', err);
                elements.transcript.textContent = 'Error: ' + err.message;
                hideUserBubble();
                setState(STATES.IDLE);
            }
        }

        // Text input handling - Terminal mode
        async function sendTextInput() {
            const input = document.getElementById('textInput');
            const text = input.value.trim();
            if (!text) return;

            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            input.disabled = true;

            try {
                await fetch('/send/' + ROOM, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '[Remote text - use remote-say] ' + text })
                });
                input.value = '';

                elements.transcript.textContent = text;
                setState(STATES.PROCESSING);

                if (processingTimeout) clearTimeout(processingTimeout);
                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                        elements.transcript.textContent = 'Tap and hold to speak';
                    }
                }, 30000);

            } catch (err) {
                console.error('Send error:', err);
            } finally {
                sendBtn.disabled = false;
                input.disabled = false;
                input.focus();
            }
        }

        // Text input handling - Ambient mode
        async function sendTextInputAmbient() {
            const input = elements.textInputAmbient;
            const text = input.value.trim();
            if (!text) return;

            const sendBtn = document.getElementById('sendBtnAmbient');
            sendBtn.disabled = true;
            input.disabled = true;

            showUserBubble(text);

            try {
                await fetch('/send/' + ROOM, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '[Remote text - use remote-say] ' + text })
                });
                input.value = '';

                setState(STATES.PROCESSING);

                // Close text input
                textInputOpen = false;
                elements.textToggleBtn.classList.remove('active');
                elements.textInputExpanded.classList.remove('open');

                if (processingTimeout) clearTimeout(processingTimeout);
                processingTimeout = setTimeout(() => {
                    if (currentState === STATES.PROCESSING) {
                        setState(STATES.IDLE);
                    }
                }, 30000);

            } catch (err) {
                console.error('Send error:', err);
            } finally {
                sendBtn.disabled = false;
                input.disabled = false;
            }
        }

        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextInput();
            }
        });

        elements.textInputAmbient.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendTextInputAmbient();
            }
        });

        // Event listeners - Ambient mode mic
        elements.micBtn.addEventListener('mousedown', startListening);
        elements.micBtn.addEventListener('mouseup', stopListening);
        elements.micBtn.addEventListener('mouseleave', stopListening);
        elements.micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startListening(); });
        elements.micBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopListening(); });

        // Event listeners - Terminal mode mic
        elements.micBtnTerminal.addEventListener('mousedown', startListening);
        elements.micBtnTerminal.addEventListener('mouseup', stopListening);
        elements.micBtnTerminal.addEventListener('mouseleave', stopListening);
        elements.micBtnTerminal.addEventListener('touchstart', (e) => { e.preventDefault(); startListening(); });
        elements.micBtnTerminal.addEventListener('touchend', (e) => { e.preventDefault(); stopListening(); });

        // Start in ambient mode by default
        toggleMode();
        connect();
        populateAudioDevices();
    </script>
</body>
</html>
